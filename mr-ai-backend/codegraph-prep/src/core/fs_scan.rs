//! Filesystem scanning with configurable filters and diagnostics.
//!
//! This module is language-agnostic. It discovers files under a given root
//! directory, applies ignore/glob filters, and records metadata for each file
//! (size, language detection, generated flag).
//!
//! Results are consumed by later pipeline stages (AST parsing, graph building).

use crate::{
    config::model::GraphConfig,
    core::normalize::{build_globset, detect_language, is_generated_by, is_ignored_by},
    model::language::LanguageKind,
};
use anyhow::{Result, bail};
use globset::GlobSet;
use std::{
    fs,
    path::{Path, PathBuf},
};
use tracing::{debug, info, warn};
use walkdir::{DirEntry, WalkDir};

/// Metadata for a single scanned file.
///
/// Includes path, detected language, file size, and whether it was flagged
/// as generated by heuristics or configured globs.
#[derive(Debug, Clone)]
pub struct ScannedFile {
    pub path: PathBuf,
    pub language: Option<LanguageKind>,
    pub size: u64,
    pub is_generated: bool,
}

/// Result of scanning a repository root.
///
/// Contains the canonical root path and all collected [`ScannedFile`]s.
#[derive(Debug, Clone)]
pub struct ScanResult {
    pub root: PathBuf,
    pub files: Vec<ScannedFile>,
}

/// Recursively scan a repository for source files, applying ignore/glob rules.
///
/// - Skips non-files (directories, symlinks if not followed).
/// - Applies configured ignore globs.
/// - Skips files larger than [`GraphConfig::limits.max_file_bytes`].
/// - Marks files as generated if they match the configured `generated_globs`.
///
/// # Arguments
/// * `root` - Root directory of the repository to scan.
/// * `cfg` - Loaded pipeline configuration.
///
/// # Returns
/// A [`ScanResult`] containing the discovered files and their metadata.
///
/// # Errors
/// Returns [`anyhow::Error`] if the root does not exist.
///
/// # Example
/// ```no_run
/// use std::path::Path;
/// use codegraph_prep::core::fs_scan::scan_repo;
/// use codegraph_prep::config::model::GraphConfig;
///
/// let cfg = GraphConfig::default();
/// let result = scan_repo(Path::new("."), &cfg).unwrap();
/// println!("{} files scanned", result.files.len());
/// ```
pub fn scan_repo(root: &Path, cfg: &GraphConfig) -> Result<ScanResult> {
    if !root.exists() {
        bail!("fs_scan: root does not exist: {}", root.display());
    }

    info!("fs_scan: start -> {}", root.display());

    let ignore_globs: Option<GlobSet> = build_globset(&cfg.filters.ignore_globs);
    let generated_globs: Option<GlobSet> = if cfg.filters.exclude_generated {
        build_globset(&cfg.filters.generated_globs)
    } else {
        None
    };

    let mut skipped_ignored = 0usize;
    let mut skipped_too_big = 0usize;
    let mut files = Vec::<ScannedFile>::new();

    let walker = WalkDir::new(root)
        .follow_links(true)
        .into_iter()
        .filter_entry(|e| keep_entry(e));

    for entry in walker.filter_map(Result::ok) {
        if !entry.file_type().is_file() {
            continue;
        }
        let path = entry.path();

        // ignore by glob
        if is_ignored_by(path, ignore_globs.as_ref()) {
            skipped_ignored += 1;
            debug!("fs_scan: ignore (glob) {}", path.display());
            continue;
        }

        let meta = match fs::metadata(path) {
            Ok(m) => m,
            Err(err) => {
                warn!("fs_scan: metadata failed for {}: {}", path.display(), err);
                continue;
            }
        };
        let size = meta.len();
        if size as usize > cfg.limits.max_file_bytes {
            skipped_too_big += 1;
            debug!(
                "fs_scan: skip (size {} > max {}) {}",
                size,
                cfg.limits.max_file_bytes,
                path.display()
            );
            continue;
        }

        let language = detect_language(path);
        let is_generated = is_generated_by(path, generated_globs.as_ref());

        files.push(ScannedFile {
            path: path.to_path_buf(),
            language,
            size,
            is_generated,
        });
    }

    info!(
        "fs_scan: done, total={} (ignored={}, too_big={})",
        files.len(),
        skipped_ignored,
        skipped_too_big
    );

    Ok(ScanResult {
        root: root.to_path_buf(),
        files,
    })
}

/// Directory filter to avoid descending into heavy/vendor folders early.
///
/// Skips known tooling or cache directories like `.git`, `node_modules`,
/// `build`, `.dart_tool`, etc.
fn keep_entry(entry: &DirEntry) -> bool {
    if entry.file_type().is_dir() {
        if let Some(name) = entry.file_name().to_str() {
            return !matches!(
                name,
                ".git" | "node_modules" | "build" | "target" | ".dart_tool" | ".idea" | ".vscode"
            );
        }
    }
    true
}
